<!-- TOC -->

* [1. 자바의 모든 클래스는 Object 클래스를 상속받습니다. 그리고 Object클래스에는 equals() 와 hashCode() 라는 메소드가 선언되어 있습니다. 이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?](#1-자바의-모든-클래스는-object-클래스를-상속받습니다-그리고-object클래스에는-equals-와-hashcode-라는-메소드가-선언되어-있습니다-이-메소드들은-각각-어떤-역할일까요-이-둘의-차이점은-무엇일까요)
  * [equals()](#equals)
  * [hashCode()](#hashcode)
* [1-1. "hashCode" 를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수가 있습니다. 어떤 케이스일 때 그럴 수 있을까요?](#1-1-hashcode-를-잘못-오버라이딩하면-hashmap-등-hash-콜렉션의-성능이-떨어질-수가-있습니다-어떤-케이스일-때-그럴-수-있을까요)
* [1-2. "HashMap"은 내부적으로 어떻게 구현되어있길래 그렇게 빨리 값을 탐색할 수 있을까요?](#1-2-hashmap은-내부적으로-어떻게-구현되어있길래-그렇게-빨리-값을-탐색할-수-있을까요)

<!-- TOC -->

# 1. 자바의 모든 클래스는 Object 클래스를 상속받습니다. 그리고 Object클래스에는 equals() 와 hashCode() 라는 메소드가 선언되어 있습니다. 이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?

## equals()

- `equals()` 메소드는 두 객체가 `논리적으로 동등한`지 확인하는 데 사용
  - 두 객체의 상태나 데이터 측면에서 동일한지 여부를 결정
- 기본적으로 `equals()` 메소드는 `메모리 위치`를 비교하지만, 객체 속성을 논리적 동등성에 따라 비교하도록 `재정의`한다.
  - `Object` 클래스의 `equals()` 메소드는 두 객체의 `참조`를 비교. (즉, 두 객체가 `메모리에서 같은 위치`에 있는지 확인합니다.)
  ```java
  //Object.java -> equals 기본 구현
  public boolean equals(Object obj) {
          return (this == obj);
      }
  ```

## hashCode()

- 해시 기반 컬렉션(예: `HashMap`)에서 사용되는 `해시 코드`를 반환.
  - `정수 해시 코드`를 반환
  - 컬렉션에 객체를 저장할 때 `버킷 위치`를 결정하는데 사용됨
- 기본적으로 `Object` 클래스의 `hashCode()` 메소드는 객체의 `메모리 주소`를 기반으로 해시 코드를 생성
  - 따로 `override` 하지 않는 다면, 객체마다 고유한 해시 코드를 제공
- 두 객체가 `equals()` 메소드에 의해 동일하게 간주되는 경우, 동일한 해시 코드를 반환해야 함

---

# 1-1. "hashCode" 를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수가 있습니다. 어떤 케이스일 때 그럴 수 있을까요?

- `hashCode()` 메소드가 다수의 서로 다른 객체에 대해 동일한 해시 코드를 생성하는 경우, 해시 충돌이 많아짐.
  <br /> 충돌이 많으면 동일한 버킷에 더 많은 객체가 저장되어 각 버킷의 `LinkedList` 혹은 `RB-Tree`를 검색할 때 속도가 느려짐
  - 효율적인 상수 시간(O(1)) 대신 선형 검색 시간(O(n))을 발생시킵니다. (`RB-Tree`의 경우 O(log n))

---

# 1-2. "HashMap"은 내부적으로 어떻게 구현되어있길래 그렇게 빨리 값을 탐색할 수 있을까요?

- `HashMap`은 내부적으로 hashCode 값을 기반으로 한 배열을 사용하고 있어서 탐색속도가 빠름.
- 해당 `HashMap`의 특징으로는 key 값이 계속 충돌나는 경우, 충돌수가 적은 초반에는 `LinkedList`로 데이터들을 보관하다가,
  <br/> 특정 임계값이 넘어가는 경우 `RB Tree`를 사용하여 데이터를 보관한다.
  - `LinkedList` 사용 이유 : 메모리가 덜 필요하고 트리 구조를 유지하는 오버헤드가 방지되므로 적은 수의 충돌에 효율적.
  - 특정 임계값 : [`Java 8` 기준 : 8]
  - `RB-Tree` 사용 이유 : `LinkedList`가 너무 길고 비효율적인 경우, 작업 성능을 향상시키기 위해 자료구조를 변경
    - 삽입, 삭제, 검색과 같은 작업에 대해 O(log n) 시간 복잡도를 가짐
- 버킷의 항목 수가 특정 임계값(Java 8 기준 이 임계값은 6) 아래로 떨어지면 `RB-Tree`가 `LinkedList`로 다시 변환
  - 적은 수의 요소에 대해 트리 구조를 유지하는 것은 효율적이지 않기 때문에 이는 메모리 사용량과 성능을 최적화하기 위해 수행
- `HashMap`이 `resize` 되는 경우 : Map의 요소 수가 `Load` 비율과 현재 `capacity`의 곱을 초과하는 경우
  - 예를 들어 `Load` 요소가 0.75 (`Java`의 기본값)이고 초기 용량이 16인 경우, `HashMap`은 13번째 요소가 추가될 때 크기가 조정
    (0.75 * 16 = 12이므로 13번째 요소를 추가하면 `resize`가 발생)
