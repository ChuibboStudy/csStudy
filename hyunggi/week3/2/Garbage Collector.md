<!-- TOC -->

* [GC란 무엇이고, 왜 써야할까요?](#gc란-무엇이고-왜-써야할까요)
  * [GC를 사용하는 이유](#gc를-사용하는-이유)
* [개발자가 메모리에 대해 신경을 덜 쓸 수 있어서 편해지는데, 그에 따른 단점은 없을까요?](#개발자가-메모리에-대해-신경을-덜-쓸-수-있어서-편해지는데-그에-따른-단점은-없을까요)
* [개발자가 GC 튜닝을 하는 궁극적인 목표는 무엇일까요?](#개발자가-gc-튜닝을-하는-궁극적인-목표는-무엇일까요)
* [G1GC부터는 GC튜닝에 크게 손이 가진 않는데, G1GC는 어떻게 만들었길래 개발자가 튜닝을 이전보다 덜 해도 되는걸까요?](#g1gc부터는-gc튜닝에-크게-손이-가진-않는데-g1gc는-어떻게-만들었길래-개발자가-튜닝을-이전보다-덜-해도-되는걸까요)
* [리전으로 구성된 구조가 왜 튜닝의 수고를 덜어주는걸까요?](#리전으로-구성된-구조가-왜-튜닝의-수고를-덜어주는걸까요)

<!-- TOC -->

# GC란 무엇이고, 왜 써야할까요?

- `가비지 컬렉션(GC)`은 Java 가상 머신(JVM)의 메모리 관리 기능 중 하나입니다.
- 프로그래머가 직접 메모리를 관리하지 않아도 되도록 도와줍니다.
- 프로그램에서 더 이상 사용되지 않는 객체(가비지)를 자동으로 탐지하고, 이를 메모리에서 해제함으로써 사용 가능한 메모리 공간을 확보합니다.

## GC를 사용하는 이유

- `메모리 관리의 자동화`: 자동 메모리 관리로 인해 개발자는 객체 생성에 집중할 수 있으며, 메모리 해제와 관련된 버그(메모리 누수, 잘못된 메모리 해제 등)를 줄일 수 있습니다.
- `프로그램의 안정성 향상`: 메모리 누수와 같은 오류를 방지하여, 프로그램의 안정성과 신뢰성을 높일 수 있습니다.
- `개발 효율성 증대`: 메모리 관리에 대한 부담이 줄어들어 개발자가 더 복잡하고 추상적인 문제에 집중할 수 있게 됩니다.

# 개발자가 메모리에 대해 신경을 덜 쓸 수 있어서 편해지는데, 그에 따른 단점은 없을까요?

- `성능 오버헤드`: GC 작업은 CPU 자원을 사용하므로, 가비지 컬렉션의 실행 시점과 지속 시간은 애플리케이션의 성능에 영향을 줄 수 있습니다. 특히, 큰 객체를 자주 생성하고 버리는 애플리케이션의 경우
  가비지 컬렉션에 의한 성능 저하가 두드러질 수 있습니다.
- `메모리 관리의 이해 부족`: 자동 메모리 관리에 의존하다 보면, 개발자가 메모리 관리의 기본 원리와 성능 최적화에 대한 이해를 상실할 수 있습니다. 이는 특히 성능에 민감한 애플리케이션을 개발할 때 문제가 될
  수 있습니다.

# 개발자가 GC 튜닝을 하는 궁극적인 목표는 무엇일까요?

- `처리량 최대화`: 이는 주어진 시간에 애플리케이션이 수행할 수 있는 작업량을 늘리는 것을 포함합니다. 높은 처리량은 처리 속도가 우선시되는 일괄 처리 또는 백엔드 애플리케이션에 매우 중요합니다.
  - `메모리 공간 관리`: 메모리 자원을 효율적으로 활용하여, 과도한 메모리 소비를 방지하는 동시에 빈번한 가비지 수집을 방지합니다.
  - `GC로 인한 지연 시간 감소`: 대화형 또는 실시간 애플리케이션의 경우 GC로 인한 일시 중지 시간을 줄이는 것이 필수적입니다. 목표는 GC가 애플리케이션 응답 시간에 미치는 영향을 최소화하는 것입니다.

# G1GC부터는 GC튜닝에 크게 손이 가진 않는데, G1GC는 어떻게 만들었길래 개발자가 튜닝을 이전보다 덜 해도 되는걸까요?

- `지역 기반 컬렉션`: G1GC는 힙을 여러 지역으로 나누어 개별적으로 관리합니다. 이 접근 방식을 사용하면 가비지가 가장 많은 지역에 집중하여 전체 일시 중지 시간을 줄여 보다 효율적인 가비지 수집이
  가능합니다.
- `예측 가능한 일시 중지 시간`: G1GC를 사용하면 사용자가 원하는 일시 중지 시간 목표를 지정할 수 있습니다. 수집기는 수집할 영역의 크기와 같은 작업을 동적으로 조정하여 이러한 목표를 달성하려고 합니다.
  이러한 예측 가능성은 일관된 응답 시간이 중요한 애플리케이션에 중요한 이점입니다.
- `동시성`: G1GC는 대부분의 작업을 애플리케이션과 동시에 수행합니다. 이렇게 하면 가비지 수집의 영향이 줄어듭니다.

# 리전으로 구성된 구조가 왜 튜닝의 수고를 덜어주는걸까요?

- `힙을 지역으로 나누기`:
  - G1GC는 Java 힙을 동일한 크기의 영역 집합으로 나눕니다. 이 분할을 통해 G1GC는 각 지역을 독립적으로 관리할 수 있습니다.
  - 지역은 포함된 개체의 연령에 따라 Eden, Survivor, Old Generation 등 다양한 유형으로 분류될 수 있습니다.

- `효율적인 GC`:
  - 힙을 여러 영역으로 나누는 것을 통해, G1GC는 가비지가 많은 영역을 먼저 수집하는 데 집중할 수 있어 전체 힙을 한 번에 수집하는 것보다 효율적입니다.
  - 이 선택적 수집 전략을 사용하면 일시 중지 시간이 더 짧고 예측 가능해지며 특히 대규모 힙에 유용합니다.

- `향상된 예측 가능성 및 제어`:
  - G1GC를 사용하면 개발자가 일시 중지 시간 목표를 설정할 수 있습니다. 이러한 목표를 사용하여 일시 중지 중에 수집할 지역을 결정합니다.
  - 일시 중지 시간에 대한 이러한 제어는 일관된 응답 시간이 필요한 응용 프로그램의 중요한 개선 사항입니다.

- `병렬성과 동시성`:
  - G1GC는 더 빠른 가비지 수집을 위해 멀티 코어 프로세서를 활용하여 여러 영역을 병렬로 처리할 수 있습니다.
  - 마킹과 같은 G1GC의 일부 단계는 애플리케이션 스레드와 동시에 수행되어 애플리케이션 처리량에 미치는 영향을 줄입니다.

- `어플리케이션의 동작에 적응 및 증분 수집`:
  - G1GC는 애플리케이션의 동작에 적응하고 일시 중지 시간 목표를 충족하기 위해 수집할 영역의 수와 크기를 자동으로 선택합니다.
  - 증분 수집은 시간이 지남에 따라 GC 작업량을 분산시켜 대규모 힙을 보다 효과적으로 관리하는 데 도움이 됩니다.
    - 증분 수집(incremental collection)은 메모리 힙 전체를 한 번에 정리하는 대신, 작은 부분이나 단계로 쓰레기를 수집하는 과정을 의미

- `압축 및 메모리 관리`:
  - G1GC는 점진적으로 압축을 수행하므로 전체 힙 압축을 피하고 일시 중지 시간이 길어지는 데 도움이 됩니다.
  - 이 접근 방식은 메모리 조각화를 줄이는 데도 도움이 되므로 메모리 사용 효율이 더욱 높아집니다.

- `애플리케이션 성능에 미치는 영향`:
  - 메모리 공간이 큰 애플리케이션은 GC 일시 중지 시간 감소 및 메모리 관리 개선으로 인해 G1GC의 지역 컬렉션 접근 방식의 이점을 크게 누릴 수 있습니다.
  - 실시간 요구 사항이 있는 애플리케이션에서는 보다 예측 가능하고 일관된 성능을 경험할 수 있습니다.
