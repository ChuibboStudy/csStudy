<!-- TOC -->

* [`Blocking IO`와 `Non-Blocking IO` 의 차이를 말씀해주세요.](#blocking-io와-non-blocking-io-의-차이를-말씀해주세요)
* [`Blocking IO` 가 일어나면 스레드에는 무슨 일이 생길까요?](#blocking-io-가-일어나면-스레드에는-무슨-일이-생길까요)
  * [스레드가 멈춰있는 동안 CPU는 어떻게 될까요?](#스레드가-멈춰있는-동안-cpu는-어떻게-될까요)
  * [CPU가 쉬는 것을 막으려면 어떻게 해야할까요?](#cpu가-쉬는-것을-막으려면-어떻게-해야할까요)
  * [스레드를 늘리면 단점이 무엇일까요?](#스레드를-늘리면-단점이-무엇일까요)
* [`Non-Blocking IO`는 CPU 활용률이 어떨까요?](#non-blocking-io는-cpu-활용률이-어떨까요)

<!-- TOC -->

# `Blocking IO`와 `Non-Blocking IO` 의 차이를 말씀해주세요.

- `Blocking IO`는 작업이 완료될 때까지 기다리는 반면, `Non-Blocking IO`는 작업이 완료되기 전에 프로세스가 계속될 수 있도록 합니다.
  - `Blocking IO` : 스레드가 `Blocking IO` 작업을 수행할 때, 작업이 끝나기 전까지는 계속 기다려야 합니다. 즉, 대기하는 동안 스레드가 다른 일을 할 수 없습니다.
  - `Non-Blocking IO` : 스레드가 `Non-Blocking IO` 작업을 할 때 스레드는 IO 작업을 시작하고 바로 다른 작업을 계속할 수 있습니다. 데이터가 아직 준비되지 않았다면, 스레드는 다른
    작업을 수행하고 나중에 다시 확인할 수 있습니다.

# `Blocking IO` 가 일어나면 스레드에는 무슨 일이 생길까요?

![Java Thread Status](https://t1.daumcdn.net/cfile/tistory/998E13365C78F67910?original)

- `Blocking IO`는 스레드가 작업이 완료될 때까지 기다려야 합니다.

## 스레드가 멈춰있는 동안 CPU는 어떻게 될까요?

- 다른 스레드를 불러와서 작업을 하게 됩니다. (컨텍스트 스위칭)

## CPU가 쉬는 것을 막으려면 어떻게 해야할까요?

- 스레드 수가 많으면 그만큼 동작해야 하는 스레드가 많기 때문에 계속해서 CPU가 돌아가게 됩니다.

## 스레드를 늘리면 단점이 무엇일까요?

- `메모리 부족` : 많은 스레드로 인해서 메모리가 부족해집니다.
- `컨텍스트 스위칭 오버헤드` : 컨텍스트 스위칭이 많이 일어나야 하기 때문에 오버헤드가 발생합니다.
  - 많은 스레드가 있다고 해서 꼭 효율적으로 동작하는 것은 아닙니다.
- `동기화 복잡성` : 스레드가 많을수록 동기화의 복잡성이 증가하여 교착 상태 및 경쟁 조건이 발생할 수 있습니다.

# `Non-Blocking IO`는 CPU 활용률이 어떨까요?

- `Non-Blocking IO`는 단일 스레드가 완료될 때까지 기다리지 않고 여러 IO 작업을 관리할 수 있도록 하여 CPU 활용도를 크게 향상시킵니다.
- 이 접근 방식은 IO를 기다리는 동안 스레드가 유휴 상태가 되는 것을 방지하여 대기 작업에서 불필요한 CPU 주기를 줄입니다.
- 특히 IO 집약적인 애플리케이션에서 더 나은 확장성과 응답성을 제공합니다.

1. 효율적인 CPU 사용량: `Non-Blocking IO`를 사용하면 스레드가 IO 작업을 시작하고 작업이 완료될 때까지 기다리지 않고 즉시 다른 작업으로 이동할 수 있습니다.
2. 다중 IO 작업 처리: `Non-Blocking IO`에서는 단일 스레드가 여러 IO 작업을 동시에 처리할 수 있습니다. 이 멀티플렉싱 기능은 IO 작업이 완료되기를 기다리는 동안 동일한 스레드가 다른 작업을
   관리할 수
   있으므로 CPU 활용도를 향상시킵니다.
3. 향상된 확장성: `Non-Blocking IO`는 각 연결에 스레드를 할당하지 않고 많은 수의 동시 연결을 처리하는 것이 중요한 네트워크 프로그래밍 및 서버 애플리케이션에 특히 유용합니다. 이 모델을 사용하면
   더 적은
   리소스로 더 많은 연결을 처리할 수 있으므로 확장성이 향상됩니다.
4. 컨텍스트 전환 감소: 스레드가 IO를 기다리면서 차단되지 않으므로 컨텍스트 전환이 더 적습니다. 이러한 감소는 효율적인 CPU 활용 및 전체 시스템 성능에 더욱 기여합니다.

> `Non-Blocking IO`는 CPU 사용률 측면에서 `Blocking IO` 작업보다 효율적인 방법입니다.
>
> 이는 더 나은 리소스 관리를 가능하게 하며 애플리케이션, 특히 IO 바인딩된 애플리케이션의 성능과 확장성을 크게 향상시킬 수 있습니다.
