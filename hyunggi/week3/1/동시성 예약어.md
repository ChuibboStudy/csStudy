<!-- TOC -->

* [자바에서 `동시성`과 관련된 예약어를 모두 말씀해주세요.](#자바에서-동시성과-관련된-예약어를-모두-말씀해주세요)
* [`volatile` 키워드는 어떤 키워드일까요?](#volatile-키워드는-어떤-키워드일까요)
  * [필드가 `volatile`으로 선언되면 JVM은 다음을 보장합니다.](#필드가-volatile으로-선언되면-jvm은-다음을-보장합니다)
  * [`volatile`은 `원자성`을 제공하지 않습니다.](#volatile은-원자성을-제공하지-않습니다)
* [`가시성`이란 ?](#가시성이란-)
* [`volatile`은 어떤 상황에 쓸 수 있을까요?](#volatile은-어떤-상황에-쓸-수-있을까요)
  * [Long 및 Double의 원자성:](#long-및-double의-원자성)
  * [스레드 간 신호 전달](#스레드-간-신호-전달)

<!-- TOC -->

# 자바에서 `동시성`과 관련된 예약어를 모두 말씀해주세요.

- 자바는 동시성을 관리하기 위해서 `synchronized`, `volatile`과 같은 특정 키워드를 사용합니다.
- `synchronized`: 객체에 대한 상호 배타적 접근을 위해 잠금을 사용합니다.
- `volatile`: 변수의 변경사항이 모든 스레드에게 보이도록 보장합니다.

# `volatile` 키워드는 어떤 키워드일까요?

- Java의 `volatile` 키워드는 변수를 `메인 메모리에 저장하고, 메인 메모리에서 읽어온다`는 것을 나타낼 때 사용됩니다.
- 이는 해당 변수에 대한 `읽기 및 쓰기가 CPU 캐시의 복사가 아닌 주 메모리에서 직접 수행되도록 보장`하여 `스레드 전체의 변수 변경 사항에 대한 가시성`을 보장합니다.

> 다중 스레드 애플리케이션에서 스레드는 종종 `성능상의 이유로 변수를 캐시`합니다.
>
> 두 스레드가 동기화 없이 동일한 변수를 읽고 쓰는 경우 값이 캐시되면 한 스레드가 다른 스레드의 변경 사항을 인식하지 못할 수 있습니다.
>
> 이러한 `가시성 부족`은 `가시성 문제`로 알려진 문제로 이어질 수 있습니다.

### 필드가 `volatile`으로 선언되면 JVM은 다음을 보장합니다.

- `volatile` 변수를 읽을 때마다 스레드의 로컬 캐시가 아닌 컴퓨터의 `주 메모리에서 읽혀집니다.`
- `volatile` 변수에 대한 모든 쓰기는 스레드의 로컬 캐시뿐만 아니라 `주 메모리에도 기록됩니다.`
- `volatile`은 컴파일러의 일반적인 성능 향상 기술인 명령어 재정렬도 방지합니다.
  - 이러한 재정렬로 인해 다중 스레드 환경에서 예기치 않은 동작이 발생할 수 있는 경우가 있습니다.
  - `volatile`을 사용하면 휘발성 변수와 관련된 명령어의 순서가 유지됩니다.

### `volatile`은 `원자성`을 제공하지 않습니다.

예를 들어, 증가 연산(`count++`)은 `volatile` 변수를 사용하더라도 `원자적`이지 않습니다.

원자성을 위해서는 `synchronized` 블럭 사용 혹은 `java.util.concurrent.atomic` 패키지의 클래스를 사용하는 것과 같은 추가 동기화가 필요합니다.

```java
public class SharedObject {
    private volatile int counter = 0; // The use of volatile guarantees visibility across threads.

    public void increment() {
        counter++;  // Warning: This operation itself is not atomic.
    }

    public int getCounter() {
        return counter;
    }
}
```

# `가시성`이란 ?

- `가시성`은 한 스레드에 의해 수행된 변수 업데이트가 다른 스레드에 표시되는 것을 의미합니다.

- 다중 스레드 환경에서 스레드는 효율성을 위해 자체 변수의 로컬 복사본을 사용하여 작업하는 경우가 많습니다.
  - 한 스레드가 해당 복사본을 수정하는 경우 변경 내용이 주 메모리나 다른 스레드의 로컬 복사본에 즉시
    반영되지 않을 수 있습니다.
  - 이로 인해 서로 다른 스레드가 변수 값에 대해 서로 다른 보기를 갖게 되는 상황이 발생할 수 있으며, 이를 `가시성 문제`라고 합니다.
- `volatile` 키워드는 휘발성 변수에 대한 `모든 읽기가 실제로 주 메모리에서 읽혀지고`, 휘발성 변수에 대한 `모든 쓰기가 주 메모리에 기록`되도록 보장합니다.
  - 이렇게 하면 휘발성 변수에 대한 모든 업데이트가 다른 모든 스레드에 즉시 표시됩니다.

# `volatile`은 어떤 상황에 쓸 수 있을까요?

- `long 변수`나 `double 변수`를 원자적으로 읽고 써야 하는 상황
- 변수가 한 스레드에 의해 수정되어 다른 스레드에서 즉시 표시되어야 하는 상황

## Long 및 Double의 원자성:

- Java에서는 `long`과 `double` 자료형이 64비트로, 일부 시스템에서 이들의 `읽기와 쓰기가 두 단계로 나뉘어 처리`될 수 있습니다.
  - 즉, 한 스레드가`long`이나`double` 변수를 업데이트하는 도중 다른 스레드가 그 값을 읽으면, 완전히 업데이트되지 않은, 즉 `반쪽짜리` 값이 읽힐 수 있습니다. 이것을 `비원자적 연산` 이라고
    합니다.
- 하지만 변수를`volatile`로 선언하면,`long`과`double`의 읽기와 쓰기 연산이 `원자적`으로 수행됩니다.
  - 원자적이라는 말은 그 연산이 중간 단계 없이 한 번에 완전히 이루어진다는 것을 의미합니다. 따라서`volatile`키워드를 사용하면, 이러한 변수에 대한 업데이트가 완전하고 안전하게 이루어집니다.

> 결론적으로,`volatile`이 선언된`long`이나`double`변수는 한 스레드에서 값을 변경하면 다른 스레드에서도 그 변경된 값을 안전하게 볼 수 있도록 보장합니다.

## 스레드 간 신호 전달

- 스레드가 상태 변경을 다른 스레드에 신호해야 하고 잠금 기반 동기화가 필요하지 않은 경우 `volatile`을 사용할 수 있습니다.
