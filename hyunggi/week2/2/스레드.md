<!-- TOC -->

* [스레드는 왜 써야하는 것일까요?](#스레드는-왜-써야하는-것일까요)
* [스레드를 쓰면 동시에 여러 일을 처리할 수 있으니 한 1만개정도 띄우면 너무 좋지 않을까요?](#스레드를-쓰면-동시에-여러-일을-처리할-수-있으니-한-1만개정도-띄우면-너무-좋지-않을까요)
* [메모리 양은 얼마나 들까요?](#메모리-양은-얼마나-들까요)
* [컨텍스트 스위칭은 비용이 얼마나 들까요? CPU 사이클 단위로 말씀해주세요.](#컨텍스트-스위칭은-비용이-얼마나-들까요-cpu-사이클-단위로-말씀해주세요)

<!-- TOC -->

# 스레드는 왜 써야하는 것일까요?

- 스레드는 단일 프로세스 내에서 작업을 동시에 실행할 수 있도록 도움을 주기 때문에 사용을 하는 것이 더 효율이 좋습니다.

- 동시성 (한번에 여러 작업을 처리): 스레드는 단일 프로세스 내에서 여러 작업을 동시에 수행할 수 있으므로 CPU 활용도가 향상되고 전체 애플리케이션 성능이 더 빨라집니다. 그리고 스레드는 UI를 정지하지 않고
  백그라운드에서 파일 I/O 또는 네트워크 작업과 같은 장기 실행 작업을 수행하여 응답성 사용자 인터페이스를 유지하는 데 도움이 됩니다.
- 프로세스 생성보다 효율적인 리소스 사용: 스레드는 프로세스의 메모리와 리소스를 공유하므로, 프로세스 생성하는 것보다 메모리 소비가 줄어들고 프로세스 생성보다 오버헤드가 작아서 컨텍스트 전환이 빠르게 수행됩니다.
- 병렬성 (병렬 처리): 멀티 코어 프로세서에서 스레드는 병렬로 실행될 수 있으므로, 동시에 여러 작업을 수행하는 애플리케이션의 기능이 더욱 향상됩니다.

# 스레드를 쓰면 동시에 여러 일을 처리할 수 있으니 한 1만개정도 띄우면 너무 좋지 않을까요?

다음과 같은 이유로 너무 많은 스레드 생성은 성능에 악영향을 줄 수 있습니다.

1. 컨텍스트 전환 오버헤드: CPU가 한 스레드 실행에서 다른 스레드 실행으로 전환할 때 각 스레드에는 컨텍스트 전환이 필요합니다. 수천 개의 스레드를 사용하면 컨텍스트 전환으로 인한 오버헤드가 커져 잠재적으로
   전체 시스템 성능이 저하될 수 있습니다.
2. 메모리 소비: 각 스레드는 특히 스택에 대해 메모리를 소비합니다. 수천 개의 스레드를 실행하면 과도한 메모리 사용으로 이어질 수 있으며, 이로 인해 특히 메모리 리소스가 제한된 애플리케이션에서 메모리
   고갈이 발생할 수 있습니다.
3. 리소스 경합: 스레드 수가 많으면 스레드가 공유 리소스를 놓고 경쟁할 가능성이 높아집니다. 이러한 경합은 교착 상태 및 경쟁 조건과 같은 문제로 이어져 시스템을 더욱 복잡하고 유지 관리하기 어렵게 만듭니다.
4. 관리 복잡성: 많은 수의 스레드를 관리하면 애플리케이션이 더 복잡해집니다. 이러한 시스템의 효율적인 작동을 디버깅, 유지 관리 및 보장하는 것이 어려워집니다.

---

# 메모리 양은 얼마나 들까요?

각 스레드에 할당된 메모리 양은 주로 스택 메모리로 구성됩니다.

이 스택의 크기는 운영 체제 및 JVM(Java Virtual Machine) 구성에 따라 다릅니다.

- 기본 스택 크기: 대부분의 JVM 구현에서 기본 스택 크기는 스레드당 약 `256KB ~ 1MB`입니다.
- 메모리 오버헤드 (TCB): 스택 메모리 외에도 스레드 관리 및 장부를 위한 추가 오버헤드가 있습니다. 이는 일반적으로 스택 크기에 비해 작지만 무시할 수 없는 수준입니다. 특히 수천 개의 스레드를 처리할 때
  더욱 그렇습니다.

각 스레드에 과도한 메모리를 할당하면 특히 많은 수의 스레드를 생성하는 애플리케이션에서 메모리가 고갈될 수 있다는 점에 유의하는 것이 중요합니다.

---

# 컨텍스트 스위칭은 비용이 얼마나 들까요? CPU 사이클 단위로 말씀해주세요.

![](https://vicente-blog.com/media/django-summernote/2021-12-23/289f16d2-1cbe-4176-9859-9886fe7ff8b1.PNG)

컨텍스트 전환은 CPU가 한 스레드 실행에서 다른 스레드 실행으로 전환할 때 발생합니다.

이 프로세스에는 오버헤드에 전체적으로 기여하는 여러 단계가 포함됩니다.

1. 현재 상태 저장: CPU는 프로그램 카운터, 레지스터 값 및 기타 상황별 정보를 포함하는 현재 스레드의 상태를 저장합니다.
2. 다음 쓰레드 상태 로드: 그런 다음 CPU는 곧 실행될 새 스레드의 저장된 상태를 로드합니다.

이 전체 프로세스에는 시간과 리소스가 필요합니다. 개별 컨텍스트 전환은 빠를 수 있지만 자주 발생하면 비용이 상당히 커집니다. 특히 CPU 시간을 놓고 경쟁하는 스레드 수가 많은 시스템에서는 더욱 그렇습니다.
CPU가 실제 작업을 실행하는 대신 스레드 간 전환에 상당한 시간을 소비하므로 오버헤드로 인해 효율성이 저하될 수 있습니다.

상태를 저장 및 로드 하는 오버 헤드 외에도 부가적인 오버헤드가 존재합니다.

바로 cache miss overhead입니다. cache에는 현재 실행 중인 process의 data가 들어있습니다.
그런데 context switch가 발생하면 이 모든 정보들이 쓸모없어질 확률이 높습니다. 그래서 그냥 cache를 비워버리죠.
그럼 context switch 직후에는 cache가 비어있으니까 계속 cache miss가 생깁니다.
따라서 memory로 가서 cache로 데이터를 올리고 CPU로 가져오는 횟수 즉, 메모리 접근 횟수가 증가하게 되어 overhead가 커집니다.
